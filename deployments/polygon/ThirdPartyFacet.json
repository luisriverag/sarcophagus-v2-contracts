{
  "address": "0x0Bbd247cfd96379295d612932284E29f9e85ae6B",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistNotOnSarcophagus",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "signatures",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "publicKeys",
          "type": "uint256"
        }
      ],
      "name": "DifferentNumberOfSignaturesAndPublicKeys",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "embalmerClaimWindowEnd",
          "type": "uint256"
        }
      ],
      "name": "EmbalmerClaimWindowPassed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "paymentAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "publicKey",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct LibTypes.Signature",
          "name": "signature",
          "type": "tuple"
        }
      ],
      "name": "InvalidAccusalSignature",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "resurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "ResurrectionTimeInPast",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusAlreadyCleaned",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusCompromised",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusInactive",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "senderAddress",
          "type": "address"
        }
      ],
      "name": "SenderNotEmbalmerOrAdmin",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "embalmerClaimWindowEnd",
          "type": "uint256"
        }
      ],
      "name": "TooEarlyForAdminClean",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "publishDeadline",
          "type": "uint256"
        }
      ],
      "name": "TooEarlyForClean",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "accuser",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalSlashedBondDistributed",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalDiggingFeesDistributed",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "accusedArchAddresses",
          "type": "address[]"
        }
      ],
      "name": "AccuseArchaeologist",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "cleaner",
          "type": "address"
        }
      ],
      "name": "Clean",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes[]",
          "name": "publicKeys",
          "type": "bytes[]"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct LibTypes.Signature[]",
          "name": "signatures",
          "type": "tuple[]"
        },
        {
          "internalType": "address",
          "name": "paymentAddress",
          "type": "address"
        }
      ],
      "name": "accuse",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "clean",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xc642fbc958354e533071374a21ad539ae584ba3555e302c293e024ba6661bf3c",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xAE9B102741a1B60C221e39CD9526Ab38c9865AB3",
    "contractAddress": null,
    "transactionIndex": 40,
    "gasUsed": "1898237",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000010000000000000000000000008000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000081000000000000000000000000000000100000010000000000000000000000000000000000000000000000000000000000080000100000",
    "blockHash": "0xd527cd0ab15a3e80effad5b99785639961690db4fc0373902733e32245efbc8f",
    "transactionHash": "0xc642fbc958354e533071374a21ad539ae584ba3555e302c293e024ba6661bf3c",
    "logs": [
      {
        "transactionIndex": 40,
        "blockNumber": 48594009,
        "transactionHash": "0xc642fbc958354e533071374a21ad539ae584ba3555e302c293e024ba6661bf3c",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000ae9b102741a1b60c221e39cd9526ab38c9865ab3",
          "0x000000000000000000000000e7e2cb8c81c10ff191a73fe266788c9ce62ec754"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000de8d84244cdcd2000000000000000000000000000000000000000000000002ac5e419270607f04000000000000000000000000000000000000000000003c8a980ee8d9fa13c7d4000000000000000000000000000000000000000000000002ab7fb40e4c13a232000000000000000000000000000000000000000000003c8a98ed765e1e60a4a6",
        "logIndex": 228,
        "blockHash": "0xd527cd0ab15a3e80effad5b99785639961690db4fc0373902733e32245efbc8f"
      }
    ],
    "blockNumber": 48594009,
    "cumulativeGasUsed": "11418428",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "d9f1b52a3dd08d38bdc5f8fbabd1bcf7",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistNotOnSarcophagus\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"signatures\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicKeys\",\"type\":\"uint256\"}],\"name\":\"DifferentNumberOfSignaturesAndPublicKeys\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"embalmerClaimWindowEnd\",\"type\":\"uint256\"}],\"name\":\"EmbalmerClaimWindowPassed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct LibTypes.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"InvalidAccusalSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resurrectionTime\",\"type\":\"uint256\"}],\"name\":\"ResurrectionTimeInPast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusAlreadyCleaned\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusCompromised\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusInactive\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"}],\"name\":\"SenderNotEmbalmerOrAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"embalmerClaimWindowEnd\",\"type\":\"uint256\"}],\"name\":\"TooEarlyForAdminClean\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishDeadline\",\"type\":\"uint256\"}],\"name\":\"TooEarlyForClean\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accuser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSlashedBondDistributed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDiggingFeesDistributed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accusedArchAddresses\",\"type\":\"address[]\"}],\"name\":\"AccuseArchaeologist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cleaner\",\"type\":\"address\"}],\"name\":\"Clean\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes[]\",\"name\":\"publicKeys\",\"type\":\"bytes[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct LibTypes.Signature[]\",\"name\":\"signatures\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"}],\"name\":\"accuse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"clean\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"DifferentNumberOfSignaturesAndPublicKeys(uint256,uint256)\":[{\"params\":{\"publicKeys\":\"the number of public keys passed into the accuse call\",\"signatures\":\"the number of signatures passed into the accuse call\"}}],\"EmbalmerClaimWindowPassed(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed clean attempt\",\"embalmerClaimWindowEnd\":\"Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\"}}],\"InvalidAccusalSignature(bytes32,address,bytes,(uint8,bytes32,bytes32))\":[{\"params\":{\"paymentAddress\":\"payment address that should have been signed\",\"publicKey\":\"publicKey that should be derived from signing key\",\"sarcoId\":\"that should have been signed\",\"signature\":\"invalid signature\"}}],\"ResurrectionTimeInPast(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed accuse attempt\",\"resurrectionTime\":\"Resurrection timestamp which has already passed\"}}],\"SarcophagusAlreadyCleaned(bytes32)\":[{\"params\":{\"sarcoId\":\"ID of sarcophagus archaeologist has attempted to publish a private key on\"}}],\"SenderNotEmbalmerOrAdmin(address)\":[{\"params\":{\"senderAddress\":\"Address of sender\"}}],\"TooEarlyForAdminClean(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed clean attempt\",\"embalmerClaimWindowEnd\":\"Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\"}}],\"TooEarlyForClean(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed clean attempt\",\"publishDeadline\":\"Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\"}}]},\"kind\":\"dev\",\"methods\":{\"accuse(bytes32,bytes[],(uint8,bytes32,bytes32)[],address)\":{\"params\":{\"paymentAddress\":\"the address to which rewards should be sent if successful\",\"publicKeys\":\"an array of public keys corresponding to leaked private keys - order must match order of signatures\",\"sarcoId\":\"The identifier of the sarcophagus having leaked private keys\",\"signatures\":\"an array of signatures of the sarcoId and payment address signed by the leaked private keys - order must match order of publicKeys\"}},\"clean(bytes32)\":{\"params\":{\"sarcoId\":\"The identifier of the sarcophagus to clean\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"DifferentNumberOfSignaturesAndPublicKeys(uint256,uint256)\":[{\"notice\":\"Emitted when accuse is called with an unequal numbers of public keys and signatures\"}],\"EmbalmerClaimWindowPassed(uint256,uint256)\":[{\"notice\":\"Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\"}],\"InvalidAccusalSignature(bytes32,address,bytes,(uint8,bytes32,bytes32))\":[{\"notice\":\"Emitted when accuse is called with an invalid signature for the supplied sarcoId, paymentAddress, and publicKey\"}],\"ResurrectionTimeInPast(uint256,uint256)\":[{\"notice\":\"Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed\"}],\"SarcophagusAlreadyCleaned(bytes32)\":[{\"notice\":\"Clean has been called on a sarcophagus that has already been cleaned\"}],\"SenderNotEmbalmerOrAdmin(address)\":[{\"notice\":\"Clean has been called by someone other than the admin or embalmer of the sarcophagus\"}],\"TooEarlyForAdminClean(uint256,uint256)\":[{\"notice\":\"Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\"}],\"TooEarlyForClean(uint256,uint256)\":[{\"notice\":\"Clean has been called before the deadline for archaeologists to publish private keys has passed\"}]},\"kind\":\"user\",\"methods\":{\"accuse(bytes32,bytes[],(uint8,bytes32,bytes32)[],address)\":{\"notice\":\"Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id and payment address generated with the leaked private keys If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus state will be updated to Accused and bonds for all remaining unaccused archaeologists will be returned\"},\"clean(bytes32)\":{\"notice\":\"If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod, their locked bonds and diggingFees may be claimed by either the embalmer or the admin embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will be able to claim remaining locked bond and diggingFees\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/ThirdPartyFacet.sol\":\"ThirdPartyFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9b72f93be69ca894d8492c244259615c4a742afc8d63720dbc8bb81087d9b238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"contracts/facets/EmbalmerFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\n\\ncontract EmbalmerFacet {\\n    /// @notice Emitted when a sarcophagus is created\\n    /// @param sarcoId Id of the new sarcophagus\\n    /// @param name Name of the new sarcophagus\\n    /// @param resurrectionTime Resurrection time of the new sarcophagus\\n    /// @param creationTime Creation time as set during negotiation, not the same as blocktime at which event is emitted\\n    /// @param embalmer Address of embalmer\\n    /// @param recipient Address of recipient\\n    /// @param cursedArchaeologists Array of addresses of cursed archaeologists\\n    /// @param totalDiggingFees Total digging fees charged to embalmer to create the sarcophagus\\n    /// @param arweaveTxId arweave tx id for the sarcophagus\\n    event CreateSarcophagus(\\n        bytes32 indexed sarcoId,\\n        string name,\\n        uint256 resurrectionTime,\\n        uint256 creationTime,\\n        address indexed embalmer,\\n        address indexed recipient,\\n        address[] cursedArchaeologists,\\n        uint256 totalDiggingFees,\\n        string arweaveTxId\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is rewrapped\\n    /// @param sarcoId Id of sarcophagus that was rewrapped\\n    /// @param resurrectionTime New resurrection time for the sarcophagus\\n    /// @param totalDiggingFees Total digging fees charged to the embalmer for the rewrap\\n    /// @param rewrapSarcophagusProtocolFees Total protocol fees charged to the embalmer for the rewrap\\n    event RewrapSarcophagus(\\n        bytes32 indexed sarcoId,\\n        uint256 resurrectionTime,\\n        uint256 totalDiggingFees,\\n        uint256 rewrapSarcophagusProtocolFees\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is buried\\n    /// @param sarcoId Id of sarcophagus that was buried\\n    event BurySarcophagus(bytes32 indexed sarcoId);\\n\\n    /// @notice Parameters of a sarcophagus, supplied during sarcophagus creation\\n    struct SarcophagusParams {\\n        string name;\\n        // highest rewrap interval cursed archaeologists have agreed to accept for lifetime of sarcophagus\\n        uint256 maximumRewrapInterval;\\n        // The timestamp beyond which the sarcophagus can no longer be rewrapped\\n        uint256 maximumResurrectionTime;\\n        address recipientAddress;\\n        uint256 resurrectionTime;\\n        uint8 threshold;\\n        uint256 creationTime;\\n    }\\n\\n    /// @notice Parameters of an archaeologist's curse, supplied during sarcophagus creation\\n    struct CurseParams {\\n        bytes publicKey;\\n        address archAddress;\\n        uint256 diggingFeePerSecond;\\n        uint256 curseFee;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an id that is already in use\\n    /// @param sarcoId Id that is already in use\\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with expired parameters\\n    /// @param currentTime Timestamp of the failed create attempt\\n    /// @param creationTime Time when the sarcophagus parameters were created\\n    /// @param creationDeadline Deadline for creation of a sarcophagus with the supplied parameters\\n    error SarcophagusParametersExpired(\\n        uint256 currentTime,\\n        uint256 creationTime,\\n        uint256 creationDeadline\\n    );\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with no archaeologists\\n    error NoArchaeologistsProvided();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a shamir secret sharing threshold of 0\\n    error ThresholdCannotBeZero();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with more required archaeologists than total archaeologists\\n    error ThresholdGreaterThanTotalNumberOfArchaeologists(\\n        uint8 threshold,\\n        uint256 totalNumberOfArchaeologists\\n    );\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an archaeologist list that contains the same archaeologist more than once\\n    error ArchaeologistListContainsDuplicate(address archaeologistAddress);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that has already passed\\n    /// @param currentTime Timestamp of the failed rewrap attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a public key that has already been assigned to another sarcophagus\\n    /// @param publicKey the duplicated public key\\n    error DuplicatePublicKey(bytes publicKey);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that exceeds the maximum rewrap interval\\n    /// @param resurrectionTime Resurrection timestamp which is too far in the future\\n    /// @param sarcophagusMaximumRewrapInterval Maximum rewrap interval set for the sarcophagus\\n    /// @param maximumPermissibleResurrectionTime Resurrection timestamp which is too far in the future\\n    error ResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    /// @notice Emitted when the resurrection time defined during sarcohpagus creation or rewrap goes past the max resurrection time\\n    /// @param resurrectionTime The resurrection time defined during the sarcophagus creation or rewrap\\n    /// @param maxResurrectionTime The maximum allowed resurrection time\\n    error ResurrectionTimePastMaxResurrectionTime(\\n        uint256 resurrectionTime,\\n        uint256 maxResurrectionTime\\n    );\\n\\n    error NewResurrectionTimeInPast(uint256 currentTime, uint256 newResurrectionTime);\\n\\n    error NewResurrectionTimeIsZero();\\n\\n    error NewResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    error ResurrectionTimeTooFarPastPreviousResurrectionTime(\\n        uint256 resurrectionTime,\\n        uint256 previousResurrectionTime\\n    );\\n\\n    /// @notice Creates a sarcophagus with the supplied parameters and locks\\n    /// a portion of each archaeologist's freeBond equal to the digging fees calculated for the duration\\n    /// of the sarcophagus until its resurrection time.\\n    ///\\n    /// Verifies that each supplied archaeologist has signed off on the sarcophagus negotiation parameters:\\n    ///    - `publicKey` that matches the private key the archaeologist is responsible for\\n    ///    - `maximumRewrapInterval` to be enforced for the lifetime of the sarcophagus. No new resurrection time for future rewraps may exceed this interval from time of rewrap.\\n    ///    - `creationTime` of sarcophagus\\n    ///    - `diggingFeePerSecond` agreed to be paid to the archaeologist during the lifetime of the sarcophagus. Paid per rewrap and publishPrivateKey. Constant.\\n    ///    - `curseFee` agreed to be paid to the archaeologist once during the lifetime of the sarcophagus to cover cost of publishPrivateKey tx. Paid either on first rewrap or publishPrivateKey if no rewrap has occurred Constant.\\n    ///\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param sarcophagusParams params to set on sarcophagus being created\\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\\n    /// @param arweaveTxId id of tx storing the sarcophagus payload on arweave\\n    function createSarcophagus(\\n        bytes32 sarcoId,\\n        SarcophagusParams calldata sarcophagusParams,\\n        CurseParams[] calldata selectedArchaeologists,\\n        string calldata arweaveTxId\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Confirm that sarcophagus with supplied id doesn't already exist\\n        if (s.sarcophagi[sarcoId].resurrectionTime != 0) {\\n            revert SarcophagusAlreadyExists(sarcoId);\\n        }\\n\\n        // Ensure too much time hasn't passed since the sarcophagus `creationTime` that has been signed\\n        // off by its cursed archaeologists.\\n        if (block.timestamp > sarcophagusParams.creationTime + s.expirationThreshold) {\\n            revert SarcophagusParametersExpired(\\n                block.timestamp,\\n                sarcophagusParams.creationTime,\\n                sarcophagusParams.creationTime + s.expirationThreshold\\n            );\\n        }\\n\\n        // Confirm that resurrection time is in the future\\n        if (block.timestamp >= sarcophagusParams.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagusParams.resurrectionTime);\\n        }\\n\\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\\n        if (\\n            block.timestamp + sarcophagusParams.maximumRewrapInterval <\\n            sarcophagusParams.resurrectionTime\\n        ) {\\n            revert ResurrectionTimeTooFarInFuture(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumRewrapInterval,\\n                block.timestamp + sarcophagusParams.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that the resurrection time is less than the max resurrection time\\n        if (sarcophagusParams.resurrectionTime > sarcophagusParams.maximumResurrectionTime) {\\n            revert ResurrectionTimePastMaxResurrectionTime(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumResurrectionTime\\n            );\\n        }\\n\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // track total digging fees due upon creation of sarcophagus\\n        uint256 totalDiggingFees;\\n\\n        {\\n            uint256 nSelectedArchs = selectedArchaeologists.length;\\n            // Validate archaeologist and threshold lengths\\n            if (nSelectedArchs == 0) {\\n                revert NoArchaeologistsProvided();\\n            }\\n\\n            if (sarcophagusParams.threshold == 0) {\\n                revert ThresholdCannotBeZero();\\n            }\\n\\n            // Ensure that k <= n in the effective k-of-n shamir secret sharing scheme\\n            // used to distribute keyshares among archaeologists\\n            if (sarcophagusParams.threshold > nSelectedArchs) {\\n                revert ThresholdGreaterThanTotalNumberOfArchaeologists(\\n                    sarcophagusParams.threshold,\\n                    nSelectedArchs\\n                );\\n            }\\n\\n            // create the sarcophagus\\n            sarcophagus.name = sarcophagusParams.name;\\n            sarcophagus.threshold = sarcophagusParams.threshold;\\n            sarcophagus.resurrectionTime = sarcophagusParams.resurrectionTime;\\n            sarcophagus.previousRewrapTime = sarcophagusParams.creationTime;\\n            sarcophagus.maximumRewrapInterval = sarcophagusParams.maximumRewrapInterval;\\n            sarcophagus.maximumResurrectionTime = sarcophagusParams.maximumResurrectionTime;\\n            sarcophagus.arweaveTxId = arweaveTxId;\\n            sarcophagus.embalmerAddress = msg.sender;\\n            sarcophagus.recipientAddress = sarcophagusParams.recipientAddress;\\n            sarcophagus.cursedArchaeologistAddresses = new address[](nSelectedArchs);\\n            sarcophagus.cursedBondPercentage = s.cursedBondPercentage;\\n\\n            for (uint256 i; i < nSelectedArchs; ) {\\n                LibUtils.revertIfArchProfileDoesNotExist(selectedArchaeologists[i].archAddress);\\n\\n                // Confirm archaeologist isn't already cursed on this sarcophagus (no duplicates)\\n                if (\\n                    sarcophagus\\n                        .cursedArchaeologists[selectedArchaeologists[i].archAddress]\\n                        .publicKey\\n                        .length != 0\\n                ) {\\n                    revert ArchaeologistListContainsDuplicate(\\n                        selectedArchaeologists[i].archAddress\\n                    );\\n                }\\n\\n                // Confirm archaeologist is not re-using a key pair\\n                if (\\n                    s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] !=\\n                    address(0)\\n                ) {\\n                    revert DuplicatePublicKey(selectedArchaeologists[i].publicKey);\\n                }\\n\\n                LibUtils.verifyArchaeologistSignature(\\n                    sarcophagusParams.maximumRewrapInterval,\\n                    sarcophagusParams.maximumResurrectionTime,\\n                    sarcophagusParams.creationTime,\\n                    selectedArchaeologists[i]\\n                );\\n\\n                // Curse the archaeologist on this sarcophagus\\n                uint256 diggingFeesDue = LibBonds.curseArchaeologist(\\n                    sarcoId,\\n                    selectedArchaeologists[i],\\n                    i\\n                );\\n\\n                totalDiggingFees += diggingFeesDue;\\n\\n                // \\\"Consume\\\" this public key so it cannot be reused in the future\\n                s.publicKeyToArchaeologistAddress[\\n                    selectedArchaeologists[i].publicKey\\n                ] = selectedArchaeologists[i].archAddress;\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            // Transfer totalDiggingFees and the protocolFees in SARCO from embalmer to this contract\\n            uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n            s.totalProtocolFees += protocolFees;\\n            s.sarcoToken.transferFrom(\\n                msg.sender,\\n                address(this),\\n                totalDiggingFees + protocolFees\\n            );\\n        }\\n        emit CreateSarcophagus(\\n            sarcoId,\\n            sarcophagusParams.name,\\n            sarcophagusParams.resurrectionTime,\\n            sarcophagusParams.creationTime,\\n            msg.sender,\\n            sarcophagusParams.recipientAddress,\\n            sarcophagus.cursedArchaeologistAddresses,\\n            totalDiggingFees,\\n            arweaveTxId\\n        );\\n    }\\n\\n    /// @notice Updates the resurrectionTime on a sarcophagus. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param resurrectionTime the new resurrection time\\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == type(uint256).max) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n\\n        // Confirm resurrection time has not yet passed\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time is in future\\n        if (block.timestamp >= resurrectionTime) {\\n            revert NewResurrectionTimeInPast(block.timestamp, resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time doesn't exceed sarcophagus's maximumRewrapInterval\\n        if (block.timestamp + sarcophagus.maximumRewrapInterval < resurrectionTime) {\\n            revert NewResurrectionTimeTooFarInFuture(\\n                resurrectionTime,\\n                sarcophagus.maximumRewrapInterval,\\n                block.timestamp + sarcophagus.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that the new resurrection time doesn't exceed the maximumResurrectionTime\\n        if (sarcophagus.maximumResurrectionTime < resurrectionTime) {\\n            revert ResurrectionTimePastMaxResurrectionTime(\\n                resurrectionTime,\\n                sarcophagus.maximumResurrectionTime\\n            );\\n        }\\n\\n        // track total digging fees to be paid by embalmer across all archaeologists on the sarcophagus\\n        uint256 totalDiggingFees;\\n\\n        // pay digging fee to each cursed archaeologist on the sarcophagus that has not been accused\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        uint256 cursedBondPercentage = sarcophagus.cursedBondPercentage;\\n\\n        uint256 nArchAddresses = archaeologistAddresses.length;\\n        for (uint256 i; i < nArchAddresses; ) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            if (!cursedArchaeologist.isAccused) {\\n                // Previous digging fees calculation ignores curseFee\\n                // curseFee rewards and bond are handled separately if this sarcophagus has not been rewrapped yet\\n                uint256 prevDiggingFees = cursedArchaeologist.diggingFeePerSecond *\\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n                uint256 newDiggingFees = cursedArchaeologist.diggingFeePerSecond *\\n                    (resurrectionTime - block.timestamp);\\n\\n                // If the new digging fees are greater than the previous digging fees, we need to\\n                // increase the archaeologist's cursed bond to cover the necessary cursed bond amount\\n                if (newDiggingFees > prevDiggingFees) {\\n                    uint256 cursedBondIncrease = ((newDiggingFees - prevDiggingFees) *\\n                        cursedBondPercentage) / 10000;\\n\\n                    // If the previous cycle's rewards can't cover the cursed bond increase, revert\\n                    if (cursedBondIncrease > prevDiggingFees) {\\n                        revert ResurrectionTimeTooFarPastPreviousResurrectionTime(\\n                            resurrectionTime,\\n                            sarcophagus.resurrectionTime\\n                        );\\n                    }\\n\\n                    // Increase the archaeologist's cursed bond using digging fees paid by the embalmer\\n                    s.archaeologistProfiles[archaeologistAddresses[i]]\\n                        .cursedBond += cursedBondIncrease;\\n\\n                    // Rewards are now previous digging fees - difference\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += (prevDiggingFees - cursedBondIncrease);\\n                } else if (newDiggingFees < prevDiggingFees) {\\n                    // New digging fees are less than the previous digging fees, so some of the cursed bond can be unlocked\\n                    uint256 cursedBondDecrease = ((prevDiggingFees - newDiggingFees) *\\n                        cursedBondPercentage) / 10000;\\n\\n                    // Decrease archaeologist's cursed bond by the difference\\n                    s\\n                        .archaeologistProfiles[archaeologistAddresses[i]]\\n                        .cursedBond -= cursedBondDecrease;\\n\\n                    // Increase archaeologist's free bond by the difference\\n                    s\\n                        .archaeologistProfiles[archaeologistAddresses[i]]\\n                        .freeBond += cursedBondDecrease;\\n\\n                    // Rewards are equal to the previous digging fees\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\\n                } else {\\n                    // Rewards are equal to the previous digging fees, the cursed bond can remain the same\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\\n                }\\n\\n                // Add digging fees due for the new interval\\n                totalDiggingFees += newDiggingFees;\\n\\n                // If sarcophagus has not been rewrapped yet, pay out the curseFee and unlock the curseFee bond\\n                if (!sarcophagus.isRewrapped) {\\n                    // Pay archaeologists the curse fee to their rewards\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += cursedArchaeologist.curseFee;\\n\\n                    // Unlock the curseFee cursed bond by debiting the cursed bond and crediting free bond\\n                    s.archaeologistProfiles[archaeologistAddresses[i]].cursedBond -= ((cursedArchaeologist.curseFee * cursedBondPercentage) / 10000);\\n                    s.archaeologistProfiles[archaeologistAddresses[i]].freeBond += ((cursedArchaeologist.curseFee * cursedBondPercentage) / 10000);\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n\\n        // Add the protocol fee to the total protocol fees in storage\\n        s.totalProtocolFees += protocolFees;\\n\\n        // Update the sarcophagus resurrectionTime and previousRewrapTime\\n        sarcophagus.resurrectionTime = resurrectionTime;\\n        sarcophagus.previousRewrapTime = block.timestamp;\\n\\n        if (!sarcophagus.isRewrapped) {\\n            sarcophagus.isRewrapped = true;\\n        }\\n\\n        // Transfer the new digging fees and protocol fees from embalmer to contract\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\\n    }\\n\\n    /// @notice Terminates a sarcophagus by setting its resurrection time to infinity and returning locked\\n    /// bonds to all innocent cursed archaeologists. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    function burySarcophagus(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == type(uint256).max) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n        // Confirm that the current resurrection time is in the future\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // for each archaeologist on the sarcophagus, unlock bond and pay digging fees\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        uint256 nArchAddresses = archaeologistAddresses.length;\\n        for (uint256 i; i < nArchAddresses; ) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            // if the archaeologist hasn't been accused transfer them their digging fees and return their locked bond\\n            if (!cursedArchaeologist.isAccused) {\\n                LibBonds.freeArchaeologist(sarcoId, archaeologistAddresses[i]);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Set resurrection time to infinity\\n        sarcophagus.resurrectionTime = type(uint256).max;\\n\\n        emit BurySarcophagus(sarcoId);\\n    }\\n}\\n\",\"keccak256\":\"0x403949a754400e0e7d29d0c026ab34df0b809a6f8379eda4cfa57bdbb9d417c2\",\"license\":\"Unlicense\"},\"contracts/facets/ThirdPartyFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\nimport {LibDiamond} from \\\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\ncontract ThirdPartyFacet {\\n    event AccuseArchaeologist(\\n        bytes32 indexed sarcoId,\\n        address indexed accuser,\\n        uint256 totalSlashedBondDistributed,\\n        uint256 totalDiggingFeesDistributed,\\n        address[] accusedArchAddresses\\n    );\\n\\n    event Clean(bytes32 indexed sarcoId, address indexed cleaner);\\n\\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a private key on\\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\\n\\n    /// @notice Clean has been called before the deadline for archaeologists to publish private keys has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param publishDeadline Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\\n\\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\\n    /// @param senderAddress Address of sender\\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\\n\\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed\\n    /// @param currentTime Timestamp of the failed accuse attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when accuse is called with an unequal numbers of public keys and signatures\\n    /// @param signatures the number of signatures passed into the accuse call\\n    /// @param publicKeys the number of public keys passed into the accuse call\\n    error DifferentNumberOfSignaturesAndPublicKeys(uint256 signatures, uint256 publicKeys);\\n\\n    /// @notice Emitted when accuse is called with an invalid signature for the supplied sarcoId, paymentAddress, and publicKey\\n    /// @param sarcoId that should have been signed\\n    /// @param paymentAddress payment address that should have been signed\\n    /// @param publicKey publicKey that should be derived from signing key\\n    /// @param signature invalid signature\\n    error InvalidAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes publicKey,\\n        LibTypes.Signature signature\\n    );\\n\\n    /// @notice If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod,\\n    /// their locked bonds and diggingFees may be claimed by either the embalmer or the admin\\n    /// embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will\\n    /// be able to claim remaining locked bond and diggingFees\\n    /// @param sarcoId The identifier of the sarcophagus to clean\\n    function clean(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer or admin\\n        if (msg.sender != sarcophagus.embalmerAddress && msg.sender != LibDiamond.contractOwner()) {\\n            revert SenderNotEmbalmerOrAdmin(msg.sender);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == type(uint256).max) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not already been cleaned\\n        if (sarcophagus.isCleaned) {\\n            revert SarcophagusAlreadyCleaned(sarcoId);\\n        }\\n\\n        // Confirm that the resurrectionTime + gracePeriod have passed\\n        if (block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod) {\\n            revert TooEarlyForClean(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\\n        }\\n\\n        // if sender is embalmer, confirm current time is within embalmerClaimWindow\\n        if (\\n            msg.sender == sarcophagus.embalmerAddress &&\\n            block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert EmbalmerClaimWindowPassed(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // if sender is admin, confirm embalmerClaimWindow has passed\\n        if (\\n            msg.sender == LibDiamond.contractOwner() &&\\n            block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert TooEarlyForAdminClean(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // sum of locked bonds and digging fees for all archaeologists that have failed to publish private keys before publish deadline and have not been accused\\n        uint256 totalDiggingFeesAndLockedBonds;\\n        uint256 nCursedArchs = sarcophagus.cursedArchaeologistAddresses.length;\\n\\n        for (uint256 i; i < nCursedArchs; ) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]];\\n\\n            // Punish archaeologists that failed to publish their private key in time\\n            if (!cursedArchaeologist.isAccused && cursedArchaeologist.privateKey == 0) {\\n                uint256 diggingFeesDue = cursedArchaeologist.diggingFeePerSecond *\\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n                if (!sarcophagus.isRewrapped) {\\n                    diggingFeesDue += cursedArchaeologist.curseFee;\\n                }\\n\\n                uint256 cursedBondDue = (diggingFeesDue * sarcophagus.cursedBondPercentage) / 10000;\\n                totalDiggingFeesAndLockedBonds += diggingFeesDue + cursedBondDue;\\n\\n                // slash the archaeologist's locked bond for the sarcophagus\\n                s.archaeologistProfiles[sarcophagus.cursedArchaeologistAddresses[i]].cursedBond -= cursedBondDue;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Transfer total slashed locked bonds plus digging fees to the embalmer if they are the caller, otherwise add\\n        // this to the contract's protocol fees\\n        if (msg.sender == sarcophagus.embalmerAddress) {\\n            s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFeesAndLockedBonds);\\n        } else {\\n            s.totalProtocolFees += totalDiggingFeesAndLockedBonds;\\n        }\\n\\n        sarcophagus.isCleaned = true;\\n        emit Clean(sarcoId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id\\n     * and payment address generated with the leaked private keys\\n     * If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be\\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\\n     *\\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus\\n     * state will be updated to Accused and bonds for all remaining unaccused archaeologists will be\\n     * returned\\n     *\\n     * @param sarcoId The identifier of the sarcophagus having leaked private keys\\n     * @param publicKeys an array of public keys corresponding to leaked private keys - order must match order of signatures\\n     * @param signatures an array of signatures of the sarcoId and payment address signed by the leaked private keys - order must match order of publicKeys\\n     * @param paymentAddress the address to which rewards should be sent if successful\\n     */\\n    function accuse(\\n        bytes32 sarcoId,\\n        bytes[] calldata publicKeys,\\n        LibTypes.Signature[] calldata signatures,\\n        address paymentAddress\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // verify that current time is not past resurrection time\\n        if (block.timestamp > sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == type(uint256).max) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        uint256 nSigs = signatures.length;\\n\\n        if (nSigs != publicKeys.length) {\\n            revert DifferentNumberOfSignaturesAndPublicKeys(nSigs, publicKeys.length);\\n        }\\n\\n        address[] memory accusedArchAddresses = new address[](nSigs);\\n\\n        // track the combined locked bond across all archaeologists being accused in this call\\n        uint256 totalCursedBond;\\n        uint256 accusalCount;\\n        for (uint256 i; i < nSigs; ) {\\n            if (\\n                !LibUtils.verifyAccusalSignature(\\n                    sarcoId,\\n                    paymentAddress,\\n                    publicKeys[i],\\n                    signatures[i]\\n                )\\n            ) {\\n                revert InvalidAccusalSignature(\\n                    sarcoId,\\n                    paymentAddress,\\n                    publicKeys[i],\\n                    signatures[i]\\n                );\\n            }\\n\\n            // look up the archaeologist responsible for the publicKey\\n            address accusedArchaeologistAddress = s.publicKeyToArchaeologistAddress[publicKeys[i]];\\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus\\n                .cursedArchaeologists[accusedArchaeologistAddress];\\n\\n            // verify the accused archaeologist is cursed on the sarcophagus\\n            if (accusedArchaeologist.publicKey.length == 0) {\\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n            }\\n\\n            // if the archaeologist has already been accused on this sarcophagus skip them without taking action\\n            if (accusedArchaeologist.isAccused) {\\n                unchecked {\\n                    ++i;\\n                }\\n                continue;\\n            }\\n\\n            // mark the archaeologist on the sarcophagus as having been accused\\n            accusedArchaeologist.isAccused = true;\\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\\n\\n            uint256 cursedBondDue = ((accusedArchaeologist.diggingFeePerSecond *\\n                (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime)) *\\n                sarcophagus.cursedBondPercentage) / 10000;\\n\\n            // If the sarcophagus has not been rewrapped, also slash the curse fee\\n            if (!sarcophagus.isRewrapped) {\\n                cursedBondDue += accusedArchaeologist.curseFee * sarcophagus.cursedBondPercentage / 10000;\\n            }\\n\\n            totalCursedBond += cursedBondDue;\\n\\n            // Slash the offending archaeologists bond\\n            s.archaeologistProfiles[accusedArchaeologistAddress].cursedBond -= cursedBondDue;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\\n        if (accusalCount == 0) {\\n            return;\\n        }\\n\\n        {\\n            uint256 nCursedArchs = sarcophagus.cursedArchaeologistAddresses.length;\\n\\n            // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\\n            if (accusalCount >= sarcophagus.threshold) {\\n                sarcophagus.isCompromised = true;\\n            } else {\\n                // if the current call hasn't resulted in at least sss threshold archaeologists being accused\\n                // check if total number of historical accusals on sarcophagus is greater than threshold\\n                uint256 totalAccusals;\\n\\n                for (uint256 i; i < nCursedArchs; ) {\\n                    if (\\n                        sarcophagus\\n                            .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                            .isAccused\\n                    ) {\\n                        ++totalAccusals;\\n                    }\\n                    unchecked {\\n                        ++i;\\n                    }\\n                }\\n                // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\\n                if (totalAccusals >= sarcophagus.threshold) {\\n                    sarcophagus.isCompromised = true;\\n                }\\n            }\\n\\n            // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\\n            // be returned to the remaining well behaved archaeologists\\n            if (sarcophagus.isCompromised) {\\n                // iterate through all archaeologist addresses on the sarcophagus\\n                for (uint256 i; i < nCursedArchs; ) {\\n                    // if the archaeologist has never been accused, release their locked bond back to them\\n                    if (\\n                        !sarcophagus\\n                            .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                            .isAccused\\n                    ) {\\n                        LibBonds.freeArchaeologist(\\n                            sarcoId,\\n                            sarcophagus.cursedArchaeologistAddresses[i]\\n                        );\\n                    }\\n                    unchecked {\\n                        ++i;\\n                    }\\n                }\\n            }\\n        }\\n\\n        uint256 halfTotalCursedBond = totalCursedBond >> 1;\\n        uint256 totalDiggingFees = totalCursedBond / (sarcophagus.cursedBondPercentage / 10000);\\n        // transfer the cursed half, plus the current digging fees, to the embalmer\\n        s.sarcoToken.transfer(\\n            sarcophagus.embalmerAddress,\\n            totalDiggingFees + halfTotalCursedBond\\n        );\\n\\n        // transfer the other half of the cursed bond to the transaction caller\\n        s.sarcoToken.transfer(paymentAddress, halfTotalCursedBond);\\n\\n        emit AccuseArchaeologist(\\n            sarcoId,\\n            msg.sender,\\n            totalCursedBond,\\n            totalDiggingFees,\\n            accusedArchAddresses\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x6d493c3c0d5bd584f4432f4c559fd431cbff1f47f5587d7453ef918fe91190c2\",\"license\":\"Unlicense\"},\"contracts/libraries/LibBonds.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"./LibErrors.sol\\\";\\n\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\nlibrary LibBonds {\\n    /// @notice Bonds the archaeologist to a sarcophagus.\\n    /// This does the following:\\n    ///   - adds the archaeologist's curse params and address to the sarcophagus\\n    ///   - calculates digging fees to be locked and later paid to archaeologist (includes curseFee)\\n    ///   - locks this amount from archaeologist's free bond; increases cursedBond by same\\n    ///   - Adds the sarcophagus' id to the archaeologist's record of bonded sarcophagi\\n    /// @param sarcoId Id of the sarcophagus with which to curse the archaeologist\\n    /// @param archaeologist The archaeologist to curse, with associated parameters of the curse\\n    ///\\n    /// @return the amount of digging fees due the embalmer for this curse\\n    function curseArchaeologist(\\n        bytes32 sarcoId,\\n        EmbalmerFacet.CurseParams calldata archaeologist,\\n        uint256 index\\n    ) internal returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        sarcophagus.cursedArchaeologists[archaeologist.archAddress] = LibTypes.CursedArchaeologist({\\n            publicKey: archaeologist.publicKey,\\n            privateKey: 0,\\n            isAccused: false,\\n            diggingFeePerSecond: archaeologist.diggingFeePerSecond,\\n            curseFee: archaeologist.curseFee\\n        });\\n        sarcophagus.cursedArchaeologistAddresses[index] = archaeologist.archAddress;\\n\\n        // Calculate digging fees due for this time period (creationTime/previousRewrapTime -> resurrectionTime)\\n        uint256 diggingFeesDue = (archaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime))\\n            + archaeologist.curseFee;\\n\\n        // Use cursed bond percentage to determine how much bond to lock up\\n        uint256 bondToCurse = (((diggingFeesDue) * s.cursedBondPercentage) / 10000);\\n\\n        // Transfer bond to curse from free bond to cursed bond\\n        s.archaeologistProfiles[archaeologist.archAddress].freeBond -= bondToCurse;\\n        s.archaeologistProfiles[archaeologist.archAddress].cursedBond += bondToCurse;\\n\\n        return diggingFeesDue;\\n    }\\n\\n    /// @notice Calculates and unlocks an archaeologist's cursed bond. Pays due digging fees to the archaeologist.\\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\\n    /// @param archaeologistAddress the address of the archaeologist to free\\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[archaeologistAddress];\\n\\n        // Calculate the digging fees to be paid since the last rewrap (or creation)\\n        uint256 diggingFeeAmount = cursedArchaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n        // If sarcophagus has not be been rewrapped yet, pay out the curseFee\\n        if (!sarcophagus.isRewrapped) {\\n            diggingFeeAmount += cursedArchaeologist.curseFee;\\n        }\\n\\n        uint256 cursedBondAmount = (diggingFeeAmount * sarcophagus.cursedBondPercentage) / 10000;\\n\\n        s.archaeologistProfiles[archaeologistAddress].cursedBond -= cursedBondAmount;\\n        s.archaeologistProfiles[archaeologistAddress].freeBond += cursedBondAmount;\\n\\n        s.archaeologistRewards[archaeologistAddress] += diggingFeeAmount;\\n    }\\n}\\n\",\"keccak256\":\"0x9e88c60f41dd607a934e30289d33f1c4ef07f6fc5bf437b090f85813f2630ad6\",\"license\":\"Unlicense\"},\"contracts/libraries/LibErrors.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\n/**\\n * @title A collection of Errors\\n * @notice This library defines all of the Errors that the Sarcophagus system\\n * uses.\\n */\\nlibrary LibErrors {\\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\\n\\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\\n\\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\\n\\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\\n\\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\\n\\n    error SarcophagusInactive(bytes32 sarcoId);\\n\\n    error SarcophagusCompromised(bytes32 sarcoId);\\n\\n    error SenderNotEmbalmer(address sender, address embalmer);\\n\\n    error InvalidSignature(\\n        // address recovered from signature via ecrecover\\n        address recoveredAddress,\\n        // address we expected to have signed the data\\n        address expectedAddress\\n    );\\n}\\n\",\"keccak256\":\"0xed77e67ab300a74738cd8ec5fe8e3bd5c166b87410051ceaabe0a7ec2e45b967\",\"license\":\"Unlicense\"},\"contracts/libraries/LibTypes.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Types shared across facets for the Sarcophagus diamond\\n */\\nlibrary LibTypes {\\n    struct Sarcophagus {\\n        // Also used for existence checks -- does not exist if 0\\n        uint256 resurrectionTime;\\n        uint256 previousRewrapTime;\\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\\n        bool isCompromised;\\n        bool isCleaned;\\n        bool isRewrapped;\\n        uint8 threshold;\\n        string name;\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        string arweaveTxId;\\n        address embalmerAddress;\\n        address recipientAddress;\\n        address[] cursedArchaeologistAddresses;\\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\\n        uint256 cursedBondPercentage;\\n    }\\n\\n    struct CursedArchaeologist {\\n        uint256 diggingFeePerSecond;\\n        // Also used for publish checks -- has not published if 0\\n        bytes32 privateKey;\\n        // Also used for curse checks -- is not bonded if length is 0\\n        bytes publicKey;\\n        bool isAccused;\\n        uint256 curseFee;\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct ArchaeologistProfile {\\n        // Also used for existence checks -- does not exist if 0\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        string peerId;\\n        uint256 minimumDiggingFeePerSecond;\\n        uint256 freeBond;\\n        uint256 cursedBond;\\n        uint256 curseFee;\\n    }\\n}\\n\",\"keccak256\":\"0x1b2f2f8c309ec6d6f4895143d290b5d99daacfee6bfd2443dfe74dc0f29e8678\",\"license\":\"Unlicense\"},\"contracts/libraries/LibUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport \\\"../facets/ThirdPartyFacet.sol\\\";\\nimport \\\"./LibTypes.sol\\\";\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\n/**\\n * @title Utility functions used within the Sarcophagus system\\n * @notice This library implements various functions that are used throughout\\n * Sarcophagus, mainly to DRY up the codebase\\n * @dev these functions are all stateless, public, pure/view\\n */\\nlibrary LibUtils {\\n    /**\\n     * @notice The archaeologist needs to sign off on two pieces of data\\n     * to guarantee their unrwap will be successful\\n     *\\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\\n     * @param curseParams parameters of curse signed by archaeologist\\n     */\\n    function verifyArchaeologistSignature(\\n        uint256 agreedMaximumRewrapInterval,\\n        uint256 maximumResurrectionTime,\\n        uint256 timestamp,\\n        EmbalmerFacet.CurseParams calldata curseParams\\n    ) internal pure {\\n        // Hash the hash of the data payload\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encode(\\n                        curseParams.publicKey,\\n                        agreedMaximumRewrapInterval,\\n                        maximumResurrectionTime,\\n                        curseParams.diggingFeePerSecond,\\n                        timestamp,\\n                        curseParams.curseFee\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Generate the address from the signature.\\n        // ecrecover should always return a valid address.\\n        address recoveredAddress = ecrecover(\\n            messageHash,\\n            curseParams.v,\\n            curseParams.r,\\n            curseParams.s\\n        );\\n\\n        if (recoveredAddress != curseParams.archAddress) {\\n            revert LibErrors.InvalidSignature(recoveredAddress, curseParams.archAddress);\\n        }\\n    }\\n\\n    /// @notice Verifies that a signature and public key were created from the same private key\\n    /// @param sarcoId the sarcoId that was signed\\n    /// @param paymentAddress the payment address that was signed\\n    /// @param publicKey an uncompressed 65 byte secp256k1 public key\\n    /// @param signature signature on the sarco id and payment address\\n    /// @return true if the signature was signed by the private key corresponding to the supplied public key\\n    function verifyAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes calldata publicKey,\\n        LibTypes.Signature calldata signature\\n    ) internal pure returns (bool) {\\n        // removes the 0x04 prefix from an uncompressed public key\\n        uint256 pubKeyLength = publicKey.length;\\n        bytes memory truncatedPublicKey = new bytes(pubKeyLength - 1);\\n        for (uint256 i = 1; i < pubKeyLength; ) {\\n            truncatedPublicKey[i - 1] = publicKey[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(abi.encode(sarcoId, paymentAddress))\\n            )\\n        );\\n        // Use ecrecover to get the address that signed the message\\n        address signingAddress = ecrecover(messageHash, signature.v, signature.r, signature.s);\\n\\n        address publicKeyAddress = address(\\n            uint160(\\n                uint256(keccak256(truncatedPublicKey)) &\\n                    0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n            )\\n        );\\n\\n        return signingAddress == publicKeyAddress;\\n    }\\n\\n    /// @notice Checks if an archaeologist profile exists and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check existence of\\n    function revertIfArchProfileExists(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval != 0) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Checks if an archaeologist profile doesn't exist and reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check lack of existence of\\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval == 0) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\\n    /// @param totalDiggingFees to be paid. Protocol fee is a percentage of this\\n    /// @return The protocol fees amount\\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 10000;\\n    }\\n}\\n\",\"keccak256\":\"0x1b411278faa2f19d4fb8f558fb1ce33f35cc367cca58b7229d5c2f8848201b48\",\"license\":\"Unlicense\"},\"contracts/storage/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\n/**\\n * Global diamond storage struct to be shared across facets\\n * TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\\n */\\nstruct AppStorage {\\n    // SARCO token contract\\n    IERC20 sarcoToken;\\n    // The Admin address allowed to call Admin Facet functions\\n    address admin;\\n    // total protocol fees available to be withdrawn by the admin\\n    uint256 totalProtocolFees;\\n    /**\\n     * Protocol level admin configurations\\n     */\\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap. Denominator is 10000\\n    uint256 protocolFeeBasePercentage;\\n    // % of digging fees archaeologists must have locked up per curse in cursed bond. Denominator is 10000\\n    uint256 cursedBondPercentage;\\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time. Specified in seconds\\n    uint256 gracePeriod;\\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated. Specified in seconds\\n    uint256 expirationThreshold;\\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys. Specified in seconds\\n    uint256 embalmerClaimWindow;\\n    // registered archaeologist addresses\\n    address[] archaeologistProfileAddresses;\\n    // public key => archaeologist address\\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\\n    // sarcophagus id => sarcophagus object\\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\\n    // archaeologist address => profile\\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\\n    // current balance of rewards available for the archaeologist to withdraw\\n    mapping(address => uint256) archaeologistRewards;\\n}\\n\\nlibrary LibAppStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"sarcophagus.storage.1\\\");\\n\\n    function getAppStorage() internal pure returns (AppStorage storage s) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x082fa963ca5f2191f5ee62d8f062a0af5f48c5d8b822dcfbf53e3504755d4f62\",\"license\":\"Unlicense\"},\"hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x2205345e83eb86f5281f159a9215a096cb6d404782619f9b8e9d7a4a46c32a37\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612173806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806397b03b531461003b578063ebad22f814610057575b600080fd5b61005560048036038101906100509190611763565b610073565b005b610071600480360381019061006c91906118a9565b610885565b005b600061007d611280565b9050600081600a016000848152602001908152602001600020905060008160000154036100e157826040517f018da6880000000000000000000000000000000000000000000000000000000081526004016100d8919061195f565b60405180910390fd5b8060070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415801561017457506101446112ad565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156101b657336040517fd5fa066e0000000000000000000000000000000000000000000000000000000081526004016101ad9190611989565b60405180910390fd5b8060020160009054906101000a900460ff161561020a57826040517f9af72b86000000000000000000000000000000000000000000000000000000008152600401610201919061195f565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81600001540361027257826040517f7c6a6d70000000000000000000000000000000000000000000000000000000008152600401610269919061195f565b60405180910390fd5b8060020160019054906101000a900460ff16156102c657826040517fc921f1850000000000000000000000000000000000000000000000000000000081526004016102bd919061195f565b60405180910390fd5b816005015481600001546102da91906119dd565b42116103325742826005015482600001546102f591906119dd565b6040517f808b7d7c000000000000000000000000000000000000000000000000000000008152600401610329929190611a20565b60405180910390fd5b8060070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480156103b257508160070154826005015482600001546103a591906119dd565b6103af91906119dd565b42115b1561041857428260070154836005015483600001546103d191906119dd565b6103db91906119dd565b6040517f569861b100000000000000000000000000000000000000000000000000000000815260040161040f929190611a20565b60405180910390fd5b6104206112ad565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614801561047c575081600701548260050154826000015461046e91906119dd565b61047891906119dd565b4211155b156104e2574282600701548360050154836000015461049b91906119dd565b6104a591906119dd565b6040517ff88af35b0000000000000000000000000000000000000000000000000000000081526004016104d9929190611a20565b60405180910390fd5b6000808260090180549050905060005b818110156106dd57600084600a01600086600901848154811061051857610517611a49565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060030160009054906101000a900460ff161580156105a457506000801b8160010154145b156106d1576000856001015486600001546105bf9190611a78565b82600001546105ce9190611aac565b90508560020160029054906101000a900460ff166105f9578160040154816105f691906119dd565b90505b600061271087600b01548361060e9190611aac565b6106189190611b1d565b9050808261062691906119dd565b8661063191906119dd565b95508088600b0160008960090187815481106106505761064f611a49565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546106c79190611a78565b9250508190555050505b816001019150506104f2565b508260070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610801578360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8460070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16846040518363ffffffff1660e01b81526004016107b8929190611b4e565b6020604051808303816000875af11580156107d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107fb9190611baf565b5061081d565b8184600201600082825461081591906119dd565b925050819055505b60018360020160016101000a81548160ff0219169083151502179055503373ffffffffffffffffffffffffffffffffffffffff16857ffa165ffb1378fffa7397821a24fb52e993eab195619a2573789fca8a9e12b26660405160405180910390a35050505050565b600061088f611280565b9050600081600a016000898152602001908152602001600020905060008160000154036108f357876040517f018da6880000000000000000000000000000000000000000000000000000000081526004016108ea919061195f565b60405180910390fd5b8060000154421115610942574281600001546040517f2458293a000000000000000000000000000000000000000000000000000000008152600401610939929190611a20565b60405180910390fd5b8060020160009054906101000a900460ff161561099657876040517f9af72b8600000000000000000000000000000000000000000000000000000000815260040161098d919061195f565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8160000154036109fe57876040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016109f5919061195f565b60405180910390fd5b6000858590509050878790508114610a525780888890506040517fcc1d5b80000000000000000000000000000000000000000000000000000000008152600401610a49929190611a20565b60405180910390fd5b60008167ffffffffffffffff811115610a6e57610a6d611bdc565b5b604051908082528060200260200182016040528015610a9c5781602001602082028036833780820191505090505b50905060008060005b84811015610e1857610af58d898e8e85818110610ac557610ac4611a49565b5b9050602002810190610ad79190611c1a565b8e8e87818110610aea57610ae9611a49565b5b9050606002016112e0565b610b79578c888d8d84818110610b0e57610b0d611a49565b5b9050602002810190610b209190611c1a565b8d8d86818110610b3357610b32611a49565b5b9050606002016040517f272bd265000000000000000000000000000000000000000000000000000000008152600401610b70959493929190611dba565b60405180910390fd5b6000876009018d8d84818110610b9257610b91611a49565b5b9050602002810190610ba49190611c1a565b604051610bb2929190611e38565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600087600a0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000816002018054610c3990611e80565b905003610c7d57336040517f82881f03000000000000000000000000000000000000000000000000000000008152600401610c749190611989565b60405180910390fd5b8060030160009054906101000a900460ff1615610ca1578260010192505050610e13565b60018160030160006101000a81548160ff02191690831515021790555081868580610ccb90611eb1565b965081518110610cde57610cdd611a49565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050600061271089600b01548a600101548b60000154610d369190611a78565b8460000154610d459190611aac565b610d4f9190611aac565b610d599190611b1d565b90508860020160029054906101000a900460ff16610da05761271089600b01548360040154610d889190611aac565b610d929190611b1d565b81610d9d91906119dd565b90505b8086610dac91906119dd565b9550808a600b0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206005016000828254610e029190611a78565b925050819055508360010193505050505b610aa5565b5060008103610e2c57505050505050611278565b6000856009018054905090508560020160039054906101000a900460ff1660ff168210610e755760018660020160006101000a81548160ff021916908315150217905550610f6c565b6000805b82811015610f305787600a016000896009018381548110610e9d57610e9c611a49565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160009054906101000a900460ff1615610f255781610f2290611eb1565b91505b806001019050610e79565b508660020160039054906101000a900460ff1660ff168110610f6a5760018760020160006101000a81548160ff0219169083151502179055505b505b8560020160009054906101000a900460ff161561107c5760005b8181101561107a5786600a016000886009018381548110610faa57610fa9611a49565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160009054906101000a900460ff1661106f5761106e8e88600901838154811061103e5761103d611a49565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166114f0565b5b806001019050610f86565b505b506000600183901c9050600061271087600b015461109a9190611b1d565b846110a59190611b1d565b90508760000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8860070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16848461111891906119dd565b6040518363ffffffff1660e01b8152600401611135929190611b4e565b6020604051808303816000875af1158015611154573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111789190611baf565b508760000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8a846040518363ffffffff1660e01b81526004016111d8929190611b4e565b6020604051808303816000875af11580156111f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121b9190611baf565b503373ffffffffffffffffffffffffffffffffffffffff168e7fe9dec50cc13b92f93757042597e26d7b2af2ac85e441e773d4701a50093ec8d886848960405161126793929190611fb7565b60405180910390a350505050505050505b505050505050565b6000807ff20877bf9d9fb9260326061ac66e420582d0e2a7736ab6a6c3afd0604e1902dd90508091505090565b60006112b76116f6565b60040160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b60008084849050905060006001826112f89190611a78565b67ffffffffffffffff81111561131157611310611bdc565b5b6040519080825280601f01601f1916602001820160405280156113435781602001600182028036833780820191505090505b5090506000600190505b828110156113cb5786868281811061136857611367611a49565b5b9050013560f81c60f81b826001836113809190611a78565b8151811061139157611390611a49565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080600101905061134d565b50600088886040516020016113e1929190611ff5565b604051602081830303815290604052805190602001206040516020016114079190612096565b604051602081830303815290604052805190602001209050600060018287600001602081019061143791906120bc565b886020013589604001356040516000815260200160405260405161145e94939291906120f8565b6020604051602081039080840390855afa158015611480573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff848051906020012060001c1690508073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16149550505050505095945050505050565b60006114fa611280565b9050600081600a0160008581526020019081526020016000209050600082600a016000868152602001908152602001600020600a0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000826001015483600001546115849190611a78565b82600001546115939190611aac565b90508260020160029054906101000a900460ff166115be578160040154816115bb91906119dd565b90505b600061271084600b0154836115d39190611aac565b6115dd9190611b1d565b90508085600b0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546116339190611a78565b925050819055508085600b0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600401600082825461168e91906119dd565b925050819055508185600c0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546116e691906119dd565b9250508190555050505050505050565b6000807fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90508091505090565b600080fd5b600080fd5b6000819050919050565b6117408161172d565b811461174b57600080fd5b50565b60008135905061175d81611737565b92915050565b60006020828403121561177957611778611723565b5b60006117878482850161174e565b91505092915050565b600080fd5b600080fd5b600080fd5b60008083601f8401126117b5576117b4611790565b5b8235905067ffffffffffffffff8111156117d2576117d1611795565b5b6020830191508360208202830111156117ee576117ed61179a565b5b9250929050565b60008083601f84011261180b5761180a611790565b5b8235905067ffffffffffffffff81111561182857611827611795565b5b6020830191508360608202830111156118445761184361179a565b5b9250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006118768261184b565b9050919050565b6118868161186b565b811461189157600080fd5b50565b6000813590506118a38161187d565b92915050565b600080600080600080608087890312156118c6576118c5611723565b5b60006118d489828a0161174e565b965050602087013567ffffffffffffffff8111156118f5576118f4611728565b5b61190189828a0161179f565b9550955050604087013567ffffffffffffffff81111561192457611923611728565b5b61193089828a016117f5565b9350935050606061194389828a01611894565b9150509295509295509295565b6119598161172d565b82525050565b60006020820190506119746000830184611950565b92915050565b6119838161186b565b82525050565b600060208201905061199e600083018461197a565b92915050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006119e8826119a4565b91506119f3836119a4565b9250828201905080821115611a0b57611a0a6119ae565b5b92915050565b611a1a816119a4565b82525050565b6000604082019050611a356000830185611a11565b611a426020830184611a11565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000611a83826119a4565b9150611a8e836119a4565b9250828203905081811115611aa657611aa56119ae565b5b92915050565b6000611ab7826119a4565b9150611ac2836119a4565b9250828202611ad0816119a4565b91508282048414831517611ae757611ae66119ae565b5b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000611b28826119a4565b9150611b33836119a4565b925082611b4357611b42611aee565b5b828204905092915050565b6000604082019050611b63600083018561197a565b611b706020830184611a11565b9392505050565b60008115159050919050565b611b8c81611b77565b8114611b9757600080fd5b50565b600081519050611ba981611b83565b92915050565b600060208284031215611bc557611bc4611723565b5b6000611bd384828501611b9a565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080fd5b600080fd5b600080fd5b60008083356001602003843603038112611c3757611c36611c0b565b5b80840192508235915067ffffffffffffffff821115611c5957611c58611c10565b5b602083019250600182023603831315611c7557611c74611c15565b5b509250929050565b600082825260208201905092915050565b82818337600083830152505050565b6000601f19601f8301169050919050565b6000611cba8385611c7d565b9350611cc7838584611c8e565b611cd083611c9d565b840190509392505050565b600060ff82169050919050565b611cf181611cdb565b8114611cfc57600080fd5b50565b600081359050611d0e81611ce8565b92915050565b6000611d236020840184611cff565b905092915050565b611d3481611cdb565b82525050565b6000611d49602084018461174e565b905092915050565b611d5a8161172d565b82525050565b60608201611d716000830183611d14565b611d7e6000850182611d2b565b50611d8c6020830183611d3a565b611d996020850182611d51565b50611da76040830183611d3a565b611db46040850182611d51565b50505050565b600060c082019050611dcf6000830188611950565b611ddc602083018761197a565b8181036040830152611def818587611cae565b9050611dfe6060830184611d60565b9695505050505050565b600081905092915050565b6000611e1f8385611e08565b9350611e2c838584611c8e565b82840190509392505050565b6000611e45828486611e13565b91508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611e9857607f821691505b602082108103611eab57611eaa611e51565b5b50919050565b6000611ebc826119a4565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611eee57611eed6119ae565b5b600182019050919050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b611f2e8161186b565b82525050565b6000611f408383611f25565b60208301905092915050565b6000602082019050919050565b6000611f6482611ef9565b611f6e8185611f04565b9350611f7983611f15565b8060005b83811015611faa578151611f918882611f34565b9750611f9c83611f4c565b925050600181019050611f7d565b5085935050505092915050565b6000606082019050611fcc6000830186611a11565b611fd96020830185611a11565b8181036040830152611feb8184611f59565b9050949350505050565b600060408201905061200a6000830185611950565b612017602083018461197a565b9392505050565b600081905092915050565b7f19457468657265756d205369676e6564204d6573736167653a0a333200000000600082015250565b600061205f601c8361201e565b915061206a82612029565b601c82019050919050565b6000819050919050565b61209061208b8261172d565b612075565b82525050565b60006120a182612052565b91506120ad828461207f565b60208201915081905092915050565b6000602082840312156120d2576120d1611723565b5b60006120e084828501611cff565b91505092915050565b6120f281611cdb565b82525050565b600060808201905061210d6000830187611950565b61211a60208301866120e9565b6121276040830185611950565b6121346060830184611950565b9594505050505056fea2646970667358221220c9ea0f89ab2b2358b5f1a215e27eaadb14487e23c50836c14a3bee09c9d11e2464736f6c63430008120033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806397b03b531461003b578063ebad22f814610057575b600080fd5b61005560048036038101906100509190611763565b610073565b005b610071600480360381019061006c91906118a9565b610885565b005b600061007d611280565b9050600081600a016000848152602001908152602001600020905060008160000154036100e157826040517f018da6880000000000000000000000000000000000000000000000000000000081526004016100d8919061195f565b60405180910390fd5b8060070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415801561017457506101446112ad565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156101b657336040517fd5fa066e0000000000000000000000000000000000000000000000000000000081526004016101ad9190611989565b60405180910390fd5b8060020160009054906101000a900460ff161561020a57826040517f9af72b86000000000000000000000000000000000000000000000000000000008152600401610201919061195f565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81600001540361027257826040517f7c6a6d70000000000000000000000000000000000000000000000000000000008152600401610269919061195f565b60405180910390fd5b8060020160019054906101000a900460ff16156102c657826040517fc921f1850000000000000000000000000000000000000000000000000000000081526004016102bd919061195f565b60405180910390fd5b816005015481600001546102da91906119dd565b42116103325742826005015482600001546102f591906119dd565b6040517f808b7d7c000000000000000000000000000000000000000000000000000000008152600401610329929190611a20565b60405180910390fd5b8060070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480156103b257508160070154826005015482600001546103a591906119dd565b6103af91906119dd565b42115b1561041857428260070154836005015483600001546103d191906119dd565b6103db91906119dd565b6040517f569861b100000000000000000000000000000000000000000000000000000000815260040161040f929190611a20565b60405180910390fd5b6104206112ad565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614801561047c575081600701548260050154826000015461046e91906119dd565b61047891906119dd565b4211155b156104e2574282600701548360050154836000015461049b91906119dd565b6104a591906119dd565b6040517ff88af35b0000000000000000000000000000000000000000000000000000000081526004016104d9929190611a20565b60405180910390fd5b6000808260090180549050905060005b818110156106dd57600084600a01600086600901848154811061051857610517611a49565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060030160009054906101000a900460ff161580156105a457506000801b8160010154145b156106d1576000856001015486600001546105bf9190611a78565b82600001546105ce9190611aac565b90508560020160029054906101000a900460ff166105f9578160040154816105f691906119dd565b90505b600061271087600b01548361060e9190611aac565b6106189190611b1d565b9050808261062691906119dd565b8661063191906119dd565b95508088600b0160008960090187815481106106505761064f611a49565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546106c79190611a78565b9250508190555050505b816001019150506104f2565b508260070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610801578360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8460070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16846040518363ffffffff1660e01b81526004016107b8929190611b4e565b6020604051808303816000875af11580156107d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107fb9190611baf565b5061081d565b8184600201600082825461081591906119dd565b925050819055505b60018360020160016101000a81548160ff0219169083151502179055503373ffffffffffffffffffffffffffffffffffffffff16857ffa165ffb1378fffa7397821a24fb52e993eab195619a2573789fca8a9e12b26660405160405180910390a35050505050565b600061088f611280565b9050600081600a016000898152602001908152602001600020905060008160000154036108f357876040517f018da6880000000000000000000000000000000000000000000000000000000081526004016108ea919061195f565b60405180910390fd5b8060000154421115610942574281600001546040517f2458293a000000000000000000000000000000000000000000000000000000008152600401610939929190611a20565b60405180910390fd5b8060020160009054906101000a900460ff161561099657876040517f9af72b8600000000000000000000000000000000000000000000000000000000815260040161098d919061195f565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8160000154036109fe57876040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016109f5919061195f565b60405180910390fd5b6000858590509050878790508114610a525780888890506040517fcc1d5b80000000000000000000000000000000000000000000000000000000008152600401610a49929190611a20565b60405180910390fd5b60008167ffffffffffffffff811115610a6e57610a6d611bdc565b5b604051908082528060200260200182016040528015610a9c5781602001602082028036833780820191505090505b50905060008060005b84811015610e1857610af58d898e8e85818110610ac557610ac4611a49565b5b9050602002810190610ad79190611c1a565b8e8e87818110610aea57610ae9611a49565b5b9050606002016112e0565b610b79578c888d8d84818110610b0e57610b0d611a49565b5b9050602002810190610b209190611c1a565b8d8d86818110610b3357610b32611a49565b5b9050606002016040517f272bd265000000000000000000000000000000000000000000000000000000008152600401610b70959493929190611dba565b60405180910390fd5b6000876009018d8d84818110610b9257610b91611a49565b5b9050602002810190610ba49190611c1a565b604051610bb2929190611e38565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600087600a0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000816002018054610c3990611e80565b905003610c7d57336040517f82881f03000000000000000000000000000000000000000000000000000000008152600401610c749190611989565b60405180910390fd5b8060030160009054906101000a900460ff1615610ca1578260010192505050610e13565b60018160030160006101000a81548160ff02191690831515021790555081868580610ccb90611eb1565b965081518110610cde57610cdd611a49565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050600061271089600b01548a600101548b60000154610d369190611a78565b8460000154610d459190611aac565b610d4f9190611aac565b610d599190611b1d565b90508860020160029054906101000a900460ff16610da05761271089600b01548360040154610d889190611aac565b610d929190611b1d565b81610d9d91906119dd565b90505b8086610dac91906119dd565b9550808a600b0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206005016000828254610e029190611a78565b925050819055508360010193505050505b610aa5565b5060008103610e2c57505050505050611278565b6000856009018054905090508560020160039054906101000a900460ff1660ff168210610e755760018660020160006101000a81548160ff021916908315150217905550610f6c565b6000805b82811015610f305787600a016000896009018381548110610e9d57610e9c611a49565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160009054906101000a900460ff1615610f255781610f2290611eb1565b91505b806001019050610e79565b508660020160039054906101000a900460ff1660ff168110610f6a5760018760020160006101000a81548160ff0219169083151502179055505b505b8560020160009054906101000a900460ff161561107c5760005b8181101561107a5786600a016000886009018381548110610faa57610fa9611a49565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160009054906101000a900460ff1661106f5761106e8e88600901838154811061103e5761103d611a49565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166114f0565b5b806001019050610f86565b505b506000600183901c9050600061271087600b015461109a9190611b1d565b846110a59190611b1d565b90508760000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8860070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16848461111891906119dd565b6040518363ffffffff1660e01b8152600401611135929190611b4e565b6020604051808303816000875af1158015611154573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111789190611baf565b508760000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8a846040518363ffffffff1660e01b81526004016111d8929190611b4e565b6020604051808303816000875af11580156111f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121b9190611baf565b503373ffffffffffffffffffffffffffffffffffffffff168e7fe9dec50cc13b92f93757042597e26d7b2af2ac85e441e773d4701a50093ec8d886848960405161126793929190611fb7565b60405180910390a350505050505050505b505050505050565b6000807ff20877bf9d9fb9260326061ac66e420582d0e2a7736ab6a6c3afd0604e1902dd90508091505090565b60006112b76116f6565b60040160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b60008084849050905060006001826112f89190611a78565b67ffffffffffffffff81111561131157611310611bdc565b5b6040519080825280601f01601f1916602001820160405280156113435781602001600182028036833780820191505090505b5090506000600190505b828110156113cb5786868281811061136857611367611a49565b5b9050013560f81c60f81b826001836113809190611a78565b8151811061139157611390611a49565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080600101905061134d565b50600088886040516020016113e1929190611ff5565b604051602081830303815290604052805190602001206040516020016114079190612096565b604051602081830303815290604052805190602001209050600060018287600001602081019061143791906120bc565b886020013589604001356040516000815260200160405260405161145e94939291906120f8565b6020604051602081039080840390855afa158015611480573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff848051906020012060001c1690508073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16149550505050505095945050505050565b60006114fa611280565b9050600081600a0160008581526020019081526020016000209050600082600a016000868152602001908152602001600020600a0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000826001015483600001546115849190611a78565b82600001546115939190611aac565b90508260020160029054906101000a900460ff166115be578160040154816115bb91906119dd565b90505b600061271084600b0154836115d39190611aac565b6115dd9190611b1d565b90508085600b0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546116339190611a78565b925050819055508085600b0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600401600082825461168e91906119dd565b925050819055508185600c0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546116e691906119dd565b9250508190555050505050505050565b6000807fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90508091505090565b600080fd5b600080fd5b6000819050919050565b6117408161172d565b811461174b57600080fd5b50565b60008135905061175d81611737565b92915050565b60006020828403121561177957611778611723565b5b60006117878482850161174e565b91505092915050565b600080fd5b600080fd5b600080fd5b60008083601f8401126117b5576117b4611790565b5b8235905067ffffffffffffffff8111156117d2576117d1611795565b5b6020830191508360208202830111156117ee576117ed61179a565b5b9250929050565b60008083601f84011261180b5761180a611790565b5b8235905067ffffffffffffffff81111561182857611827611795565b5b6020830191508360608202830111156118445761184361179a565b5b9250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006118768261184b565b9050919050565b6118868161186b565b811461189157600080fd5b50565b6000813590506118a38161187d565b92915050565b600080600080600080608087890312156118c6576118c5611723565b5b60006118d489828a0161174e565b965050602087013567ffffffffffffffff8111156118f5576118f4611728565b5b61190189828a0161179f565b9550955050604087013567ffffffffffffffff81111561192457611923611728565b5b61193089828a016117f5565b9350935050606061194389828a01611894565b9150509295509295509295565b6119598161172d565b82525050565b60006020820190506119746000830184611950565b92915050565b6119838161186b565b82525050565b600060208201905061199e600083018461197a565b92915050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006119e8826119a4565b91506119f3836119a4565b9250828201905080821115611a0b57611a0a6119ae565b5b92915050565b611a1a816119a4565b82525050565b6000604082019050611a356000830185611a11565b611a426020830184611a11565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000611a83826119a4565b9150611a8e836119a4565b9250828203905081811115611aa657611aa56119ae565b5b92915050565b6000611ab7826119a4565b9150611ac2836119a4565b9250828202611ad0816119a4565b91508282048414831517611ae757611ae66119ae565b5b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000611b28826119a4565b9150611b33836119a4565b925082611b4357611b42611aee565b5b828204905092915050565b6000604082019050611b63600083018561197a565b611b706020830184611a11565b9392505050565b60008115159050919050565b611b8c81611b77565b8114611b9757600080fd5b50565b600081519050611ba981611b83565b92915050565b600060208284031215611bc557611bc4611723565b5b6000611bd384828501611b9a565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080fd5b600080fd5b600080fd5b60008083356001602003843603038112611c3757611c36611c0b565b5b80840192508235915067ffffffffffffffff821115611c5957611c58611c10565b5b602083019250600182023603831315611c7557611c74611c15565b5b509250929050565b600082825260208201905092915050565b82818337600083830152505050565b6000601f19601f8301169050919050565b6000611cba8385611c7d565b9350611cc7838584611c8e565b611cd083611c9d565b840190509392505050565b600060ff82169050919050565b611cf181611cdb565b8114611cfc57600080fd5b50565b600081359050611d0e81611ce8565b92915050565b6000611d236020840184611cff565b905092915050565b611d3481611cdb565b82525050565b6000611d49602084018461174e565b905092915050565b611d5a8161172d565b82525050565b60608201611d716000830183611d14565b611d7e6000850182611d2b565b50611d8c6020830183611d3a565b611d996020850182611d51565b50611da76040830183611d3a565b611db46040850182611d51565b50505050565b600060c082019050611dcf6000830188611950565b611ddc602083018761197a565b8181036040830152611def818587611cae565b9050611dfe6060830184611d60565b9695505050505050565b600081905092915050565b6000611e1f8385611e08565b9350611e2c838584611c8e565b82840190509392505050565b6000611e45828486611e13565b91508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611e9857607f821691505b602082108103611eab57611eaa611e51565b5b50919050565b6000611ebc826119a4565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611eee57611eed6119ae565b5b600182019050919050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b611f2e8161186b565b82525050565b6000611f408383611f25565b60208301905092915050565b6000602082019050919050565b6000611f6482611ef9565b611f6e8185611f04565b9350611f7983611f15565b8060005b83811015611faa578151611f918882611f34565b9750611f9c83611f4c565b925050600181019050611f7d565b5085935050505092915050565b6000606082019050611fcc6000830186611a11565b611fd96020830185611a11565b8181036040830152611feb8184611f59565b9050949350505050565b600060408201905061200a6000830185611950565b612017602083018461197a565b9392505050565b600081905092915050565b7f19457468657265756d205369676e6564204d6573736167653a0a333200000000600082015250565b600061205f601c8361201e565b915061206a82612029565b601c82019050919050565b6000819050919050565b61209061208b8261172d565b612075565b82525050565b60006120a182612052565b91506120ad828461207f565b60208201915081905092915050565b6000602082840312156120d2576120d1611723565b5b60006120e084828501611cff565b91505092915050565b6120f281611cdb565b82525050565b600060808201905061210d6000830187611950565b61211a60208301866120e9565b6121276040830185611950565b6121346060830184611950565b9594505050505056fea2646970667358221220c9ea0f89ab2b2358b5f1a215e27eaadb14487e23c50836c14a3bee09c9d11e2464736f6c63430008120033",
  "devdoc": {
    "errors": {
      "DifferentNumberOfSignaturesAndPublicKeys(uint256,uint256)": [
        {
          "params": {
            "publicKeys": "the number of public keys passed into the accuse call",
            "signatures": "the number of signatures passed into the accuse call"
          }
        }
      ],
      "EmbalmerClaimWindowPassed(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed clean attempt",
            "embalmerClaimWindowEnd": "Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow"
          }
        }
      ],
      "InvalidAccusalSignature(bytes32,address,bytes,(uint8,bytes32,bytes32))": [
        {
          "params": {
            "paymentAddress": "payment address that should have been signed",
            "publicKey": "publicKey that should be derived from signing key",
            "sarcoId": "that should have been signed",
            "signature": "invalid signature"
          }
        }
      ],
      "ResurrectionTimeInPast(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed accuse attempt",
            "resurrectionTime": "Resurrection timestamp which has already passed"
          }
        }
      ],
      "SarcophagusAlreadyCleaned(bytes32)": [
        {
          "params": {
            "sarcoId": "ID of sarcophagus archaeologist has attempted to publish a private key on"
          }
        }
      ],
      "SenderNotEmbalmerOrAdmin(address)": [
        {
          "params": {
            "senderAddress": "Address of sender"
          }
        }
      ],
      "TooEarlyForAdminClean(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed clean attempt",
            "embalmerClaimWindowEnd": "Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow"
          }
        }
      ],
      "TooEarlyForClean(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed clean attempt",
            "publishDeadline": "Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod"
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "accuse(bytes32,bytes[],(uint8,bytes32,bytes32)[],address)": {
        "params": {
          "paymentAddress": "the address to which rewards should be sent if successful",
          "publicKeys": "an array of public keys corresponding to leaked private keys - order must match order of signatures",
          "sarcoId": "The identifier of the sarcophagus having leaked private keys",
          "signatures": "an array of signatures of the sarcoId and payment address signed by the leaked private keys - order must match order of publicKeys"
        }
      },
      "clean(bytes32)": {
        "params": {
          "sarcoId": "The identifier of the sarcophagus to clean"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "DifferentNumberOfSignaturesAndPublicKeys(uint256,uint256)": [
        {
          "notice": "Emitted when accuse is called with an unequal numbers of public keys and signatures"
        }
      ],
      "EmbalmerClaimWindowPassed(uint256,uint256)": [
        {
          "notice": "Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed"
        }
      ],
      "InvalidAccusalSignature(bytes32,address,bytes,(uint8,bytes32,bytes32))": [
        {
          "notice": "Emitted when accuse is called with an invalid signature for the supplied sarcoId, paymentAddress, and publicKey"
        }
      ],
      "ResurrectionTimeInPast(uint256,uint256)": [
        {
          "notice": "Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed"
        }
      ],
      "SarcophagusAlreadyCleaned(bytes32)": [
        {
          "notice": "Clean has been called on a sarcophagus that has already been cleaned"
        }
      ],
      "SenderNotEmbalmerOrAdmin(address)": [
        {
          "notice": "Clean has been called by someone other than the admin or embalmer of the sarcophagus"
        }
      ],
      "TooEarlyForAdminClean(uint256,uint256)": [
        {
          "notice": "Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed"
        }
      ],
      "TooEarlyForClean(uint256,uint256)": [
        {
          "notice": "Clean has been called before the deadline for archaeologists to publish private keys has passed"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "accuse(bytes32,bytes[],(uint8,bytes32,bytes32)[],address)": {
        "notice": "Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id and payment address generated with the leaked private keys If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus state will be updated to Accused and bonds for all remaining unaccused archaeologists will be returned"
      },
      "clean(bytes32)": {
        "notice": "If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod, their locked bonds and diggingFees may be claimed by either the embalmer or the admin embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will be able to claim remaining locked bond and diggingFees"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}